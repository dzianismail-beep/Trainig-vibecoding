<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris Game</title>
    <style>
        body { background: #222; color: #fff; font-family: Arial, sans-serif; text-align: center; margin: 0; padding: 10px; }
        canvas { background: #111; display: block; margin: 20px auto; border: 2px solid #444; max-width: 100%; height: auto; }
        #score { font-size: 1.2em; margin-top: 10px; }
        #game-over { color: #f00; font-size: 2em; margin-top: 20px; display: none; }
        @media (max-width: 480px) {
            h1 { font-size: 1.5em; margin: 10px 0; }
            canvas { margin: 10px auto; }
            #score { font-size: 1.1em; }
            #game-over { font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <h1>Tetris Game</h1>
    <button id="restart" style="padding: 15px 30px; font-size: 1.1em; border-radius: 10px; border: none; background: #28a745; color: #fff; cursor: pointer; transition: background 0.2s; font-weight: bold; margin-bottom: 20px;" title="Restart the game">üîÅ Restart Game</button>
    <canvas id="tetris" width="300" height="600"></canvas>
    <div id="score">Score: 0</div>
    <div id="game-over">Game Over</div>
    <div id="controls" style="margin: 20px 0; display: flex; flex-direction: column; align-items: center; gap: 10px; max-width: 300px; margin: 20px auto;">
        <div style="display: flex; gap: 10px; width: 100%;">
            <button id="moveLeft" style="flex: 1; padding: 15px 10px; font-size: 1.1em; border-radius: 10px; border: none; background: #444; color: #fff; cursor: pointer; transition: background 0.2s; min-height: 50px;" title="Move Left (‚Üê Arrow Key)">‚¨ÖÔ∏è Left</button>
            <button id="rotate" style="flex: 1; padding: 15px 10px; font-size: 1.1em; border-radius: 10px; border: none; background: #444; color: #fff; cursor: pointer; transition: background 0.2s; min-height: 50px;" title="Rotate Piece (Space Bar)">üîÑ Rotate</button>
            <button id="moveRight" style="flex: 1; padding: 15px 10px; font-size: 1.1em; border-radius: 10px; border: none; background: #444; color: #fff; cursor: pointer; transition: background 0.2s; min-height: 50px;" title="Move Right (‚Üí Arrow Key)">‚û°Ô∏è Right</button>
        </div>
        <div style="display: flex; gap: 10px; width: 100%;">
            <button id="moveDown" style="flex: 1; padding: 15px 10px; font-size: 1.1em; border-radius: 10px; border: none; background: #444; color: #fff; cursor: pointer; transition: background 0.2s; min-height: 50px;" title="Move Down (‚Üì Arrow Key)">‚¨áÔ∏è Down</button>
        </div>
    </div>
    <script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const COLS = 10, ROWS = 20, BLOCK = 30;
const COLORS = [
    null,
    '#0ff', // I
    '#00f', // J
    '#fa0', // L
    '#ff0', // O
    '#0f0', // S
    '#f00', // Z
    '#808', // T
];
const SHAPES = [
    [],
    [[1, 1, 1, 1]], // I
    [[1, 0, 0], [1, 1, 1]], // J
    [[0, 0, 1], [1, 1, 1]], // L
    [[1, 1], [1, 1]], // O
    [[0, 1, 1], [1, 1, 0]], // S
    [[1, 1, 0], [0, 1, 1]], // Z
    [[0, 1, 0], [1, 1, 1]], // T
];
function randomPiece() {
    const type = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
    return {
        shape: SHAPES[type].map(row => [...row]),
        color: COLORS[type],
        x: Math.floor(COLS / 2) - Math.ceil(SHAPES[type][0].length / 2),
        y: 0,
        type,
    };
}
function rotate(shape) {
    return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
}
let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
let piece = randomPiece();
let score = 0;
let gameOver = false;
function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
    ctx.strokeStyle = '#444';
    ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
}
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (board[y][x]) drawBlock(x, y, COLORS[board[y][x]]);
        }
    }
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) drawBlock(piece.x + x, piece.y + y, piece.color);
        }
    }
}
function valid(shape, offsetX, offsetY) {
    for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
                let nx = x + offsetX, ny = y + offsetY;
                if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return false;
                if (board[ny][nx]) return false;
            }
        }
    }
    return true;
}
function merge() {
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) board[piece.y + y][piece.x + x] = piece.type;
        }
    }
}
function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
            if (!board[y][x]) continue outer;
        }
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        lines++;
        y++;
    }
    score += lines * 100;
    document.getElementById('score').textContent = 'Score: ' + score;
}
function drop() {
    while (valid(piece.shape, piece.x, piece.y + 1)) piece.y++;
    tick();
}
function tick() {
    if (gameOver) return;
    if (valid(piece.shape, piece.x, piece.y + 1)) {
        piece.y++;
    } else {
        merge();
        clearLines();
        piece = randomPiece();
        if (!valid(piece.shape, piece.x, piece.y)) {
            gameOver = true;
            document.getElementById('game-over').style.display = 'block';
        }
    }
    draw();
}
function move(dx) {
    if (valid(piece.shape, piece.x + dx, piece.y)) piece.x += dx;
    draw();
}
function rotatePiece() {
    const rotated = rotate(piece.shape);
    if (valid(rotated, piece.x, piece.y)) piece.shape = rotated;
    draw();
}
document.addEventListener('keydown', e => {
    if (gameOver) return;
    if (e.key === 'ArrowLeft') move(-1);
    else if (e.key === 'ArrowRight') move(1);
    else if (e.key === 'ArrowDown') tick();
    else if (e.key === ' ') {
        e.preventDefault(); // Prevent page scrolling
        rotatePiece();
    }
    else if (e.key === 'ArrowUp') drop();
});
function gameLoop() {
    if (!gameOver) tick();
    setTimeout(gameLoop, 500);
}
draw();
gameLoop();

// Button controls
document.getElementById('moveLeft').onclick = function() {
    if (!gameOver) move(-1);
};
document.getElementById('moveRight').onclick = function() {
    if (!gameOver) move(1);
};
document.getElementById('moveDown').onclick = function() {
    if (!gameOver) tick();
};
document.getElementById('rotate').onclick = function() {
    if (!gameOver) rotatePiece();
};
document.getElementById('restart').onclick = function() {
    // Reset game state
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    piece = randomPiece();
    score = 0;
    gameOver = false;
    document.getElementById('score').textContent = 'Score: 0';
    document.getElementById('game-over').style.display = 'none';
    draw();
};
    </script>
</body>
</html>
